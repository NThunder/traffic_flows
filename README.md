# traffic_flows

## Запуск юнит-тестов

Для запуска всех юнит-тестов выполните:

```bash
python -m pytest unit_tests/ -v
```

Для запуска тестов только для определенного модуля:

```bash
python -m pytest unit_tests/test_florian.py -v
```

```bash
python -m pytest unit_tests/test_visualization.py -v
```

### Запуск
```bash
pip install -r requirements.txt
pip install -e .
python3 ./comparisons/compare_volumes.py
```

## Математическая модель

### Обозначения
- $G = (N, A)$ — транспортная сеть, где $N$ — множество остановок, $A$ — множество рёбер (маршрутов)
- $d_{ij}$ — время в пути по ребру $(i,j) \in A$
- $h_{ij}$ — интервал движения (headway) для маршрута из $i$ в $j$
- $f_{ij} = 1/h_{ij}$ — частота движения (при $h_{ij} > 0$)
- $D$ — пункт назначения
- $u_i$ — ожидаемое время в пути от остановки $i$ до $D$
- $f_i$ — суммарная частота оптимальных маршрутов из остановки $i$

---

## Оригинальный алгоритм Spiess-Florian (1989)

**Цель:** Минимизация ожидаемого времени в пути до пункта назначения $D$.

### Шаг 1: Поиск оптимальной стратегии
Инициализация:
$$
u_i = \begin{cases} 
0 & \text{если } i = D \\
+\infty & \text{иначе}
\end{cases}, \quad f_i = 0 \quad \forall i \in N
$$

Для каждого ребра $(i,j) \in A$ вычисляем приоритет:
$$
\pi_{ij} = u_j + d_{ij}
$$

Алгоритм обновляет метки узлов:
$$
u_i \leftarrow \frac{f_i \cdot u_i + f_{ij} \cdot (u_j + d_{ij})}{f_i + f_{ij}}
$$
$$
f_i \leftarrow f_i + f_{ij}
$$

где $f_{ij} = 1/h_{ij}$ — частота маршрута $(i,j)$.

### Шаг 2: Распределение пассажиропотоков
Объём пассажиров на ребре $(i,j)$:
$$
v_{ij} = \left(\frac{f_{ij}}{f_i}\right) \cdot V_i
$$
где $V_i$ — объём пассажиров в узле $i$.

Уравнение сохранения потока:
$$
V_j = V_j + v_{ij}, \quad V_D = -\sum_{i \neq D} V_i
$$

---

## Модифицированная версия: Maximize On-Time Arrival Probability

**Цель:** Максимизация вероятности прибытия в пункт назначения $D$ до заданного времени $T$.

### Шаг 1: Вероятностная модель времени в пути
Время в пути моделируется как нормальная случайная величина:
$$
X_i \sim \mathcal{N}(\mu_i, \sigma_i^2)
$$
где:
- $\mu_i$ — ожидаемое время от $i$ до $D$
- $\sigma_i^2$ — дисперсия времени

Для ребра $(i,j)$:
$$
\mu_{ij} = \frac{1}{f_{ij}} + d_{ij} + \mu_j
$$
$$
\sigma_{ij}^2 = \frac{1}{f_{ij}} + \sigma_j^2
$$

Вероятность прибытия вовремя:
$$
R_i = P(X_i \leq T) = \Phi\left(\frac{T - \mu_i}{\sigma_i}\right)
$$
где $\Phi$ — функция стандартного нормального распределения.

### Шаг 2: Risk-Averse критерий (рекомендуется)
Вместо прямой максимизации $R_i$ используем risk-averse критерий:
$$
\text{Score}_i = \mu_i + \alpha \cdot \sigma_i
$$
где $\alpha$ — коэффициент неприятия риска ($\alpha = 1.65$ для 95% надежности).

Алгоритм минимизирует $\text{Score}_i$ вместо максимизации $R_i$, что корректно учитывает дисперсию.

### Шаг 3: Обновление стратегии
При рассмотрении ребра $(i,j)$:
$$
\mu_i^{\text{new}} = \frac{f_i \cdot \mu_i + f_{ij} \cdot \mu_{ij}}{f_i + f_{ij}}
$$
$$
\sigma_i^{2,\text{new}} = \frac{f_i \cdot (\sigma_i^2 + \mu_i^2) + f_{ij} \cdot (\sigma_{ij}^2 + \mu_{ij}^2)}{f_i + f_{ij}} - (\mu_i^{\text{new}})^2
$$

Обновление происходит, если:
$$
R_i^{\text{new}} > R_i^{\text{old}} + \epsilon \quad \text{или} \quad (R_i^{\text{new}} \approx R_i^{\text{old}} \text{ и } \mu_i^{\text{new}} < \mu_i^{\text{old}})
$$

### Шаг 4: Распределение пассажиропотоков
Аналогично оригинальному алгоритму, но с использованием обновлённых частот $f_i$ из risk-averse стратегии.

---

## Ключевые преимущества модифицированной версии

1. **Учёт надёжности:** Пассажиры предпочитают маршруты с предсказуемым временем в пути
2. **Risk-averse подход:** При одинаковом ожидаемом времени выбирается маршрут с меньшей дисперсией
3. **Гибкость:** Параметр $\alpha$ позволяет настраивать уровень неприятия риска
4. **Реалистичность:** Моделирует поведение пассажиров в условиях неопределённости

> **Примечание:** При $\alpha = 0$ и $\sigma_i = 0$ модифицированная версия вырождается в оригинальный алгоритм Spiess-Florian.